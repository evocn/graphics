
// "Graphics" project
// Build Program

// This file contains a metaprogram whose objective is to build the target program contained in source/.

// While Jai is in beta, we are going to work off of specific versions of the compiler.
// The program should not build unless your compiler is this version:
MANDATORY_COMPILER_VERSION :: Version_Info.{0, 2, 17};

// Shared between the build program and the target program.
shared_data :: #string DONE

build_settings : struct {
    configuration : enum {
        DEBUG;
        RELEASE;
    }
}

program_title :: "Graphics";

compiled_shaders_directory :: "shaders/compiled";
source\ _shaders_directory :: "shaders";


DONE
#run add_build_string(shared_data, w = -1);

////////////////////////////////////////////////////////////////////////////////

// For some reason, #filepath has a trailing "/". I do this to work around it.
root := #filepath;
#run root.count -= 1;

build :: () {
    // Build Program (this one) settings.
    {
        this_program_options: Build_Options_During_Compile;
        this_program_options.do_output = false; // No executable generated by this program.
        this_program_options.write_added_strings = false;

        set_build_options_dc(this_program_options);
    }

    // Create target program workspace
    w := compiler_create_workspace("Final Program");
    if !w {
        print("Workspace creation failed.\n");
        return;
    }
    options := get_build_options(w);

    // Handle command-line arguments
    arguments := options.compile_time_command_line;
    {
        for argument: arguments {
            if argument == "build.jai" then continue;
            if argument == {
                case "-debug"; {
                    build_settings.configuration = .DEBUG;
                }
                case "-release"; {
                    build_settings.configuration = .RELEASE;
                }
                case; {
                    log_error("Unknown argument %.\n Exiting.", argument);
                    return;
                }
            }
        }

        log("Build settings: %\n", build_settings);
    }

    // Init plugins
    {
        success, plugins_to_create := parse_plugin_arguments(arguments);
        init_plugins(plugins_to_create, *plugins, w);
    }

    // Verify that we are building with a specific version of the compiler.
    // This is important since the compiler is still in beta and changing a lot.
    {
        operator == :: (a: Version_Info, b: Version_Info) -> bool {
            return a.major == b.major && a.minor == b.minor && a.micro == b.micro;
        }

        queried_version_info : Version_Info;
        version_info_string := compiler_get_version_info(*queried_version_info);
        log("Compiling the target program with %\n", version_info_string);

        if queried_version_info != MANDATORY_COMPILER_VERSION {
            log_error("Compile this with version % instead.", MANDATORY_COMPILER_VERSION);
            return;
        }
    }

    // Build options for the Target Workspace
    {
        options.output_executable_name = program_title;

        options.output_path = "bin";
        options.intermediate_path = "bin/.build";
        options.output_type = .EXECUTABLE;
        options.entry_point_name = "main";

        // Configure Compiler output printing
        options.text_output_flags = 0;
        //options.text_output_flags |= .OUTPUT_LINK_LINE;
        options.text_output_flags |= .OUTPUT_TIMING_INFO;

        if build_settings.configuration == {
            case .DEBUG;    set_optimization(*options, .DEBUG);
            case .RELEASE;  set_optimization(*options, .VERY_OPTIMIZED);
        }

        //log("%\n", options);
        set_build_options(options, w);
    }

    // Compile the target program
    {
        log("Starting compilation now!\n");

        // Interception begins
        intercept_flags: Intercept_Flags;
        for plugins if it.before_intercept it.before_intercept(it, *intercept_flags);

        compiler_begin_intercept(w, intercept_flags);

        // Add files to the Target Workspace
        {
            for plugins if it.add_source it.add_source(it);

            // Files to compile
            {
                add_build_file(tprint("%/source/main.jai", root), w);
            }

            {
                // Add shared data to the target program.
                add_build_string(shared_data, w);

                // Also tell the target program what kind of build this is.
                build_configuration_string : string;
                build_configuration_string = tprint("BUILD_TYPE :: build_settings.configuration.%;", build_settings.configuration);
                add_build_string(build_configuration_string, w);
            }
        }

        // Message loop
        {
            // Ctags module setup
            ctags: CTags;
            defer reset(*ctags);
            ctags.output_filename = "tags";
            ctags.base_path = sprint("%", root);
            defer free(ctags.base_path);

            while true {
                message := compiler_wait_for_message();
                if !message continue;

                if message.workspace == w {
                    process_message(*ctags, message);

                    for plugin : plugins if plugin.message plugin.message(plugin, message);
                }

                if message.kind == .COMPLETE break;
            }
        }

        compiler_end_intercept(w);

        for plugins if it.finish it.finish(it);
        for plugins if it.shutdown it.shutdown(it);
    }

    // Publishing work
    {
        log("\nCompilation ended on the target workspace. On to publishing work!");

        executable_path := sprint("%/%.exe", options.output_path, options.output_executable_name);
        defer free(executable_path);

        icon_path :: "assets/publishing/icon.png";

        #if OS == .WINDOWS {
            log("\n---\n");
            create_and_apply_manifest_and_icon_files(executable_path, icon_path);
        }
    }
}

#run,stallable build(); // If plugins have assertions, they may stall.

////////////////////////////////////////////////////////////////////////////////

#if OS == .WINDOWS {
create_and_apply_manifest_and_icon_files :: (executable_path : string, icon_path : string) {
    #import "Ico_File";
    #import "Windows_Resources";

    log("Creating manifest file for Windows and an icon from the file at %.", icon_path);

    success : bool;

    manifest_options: Manifest_Options;

    success = add_manifest_to_executable(executable_path, manifest_options);

    log("Manifest added: %\n", success);

    ico_data := create_ico_file_from_bitmap_filename(icon_path);
    defer free(ico_data);

    ico_path := sprint("%.ico", path_strip_extension(icon_path));
    defer free(ico_path);
    // Save .ico back out for inspection
    {
        write_entire_file(ico_path, ico_data);
    }

    success = set_icon_by_data(executable_path, ico_data);
    log("Icon     added: %\n", success);
}
}

////////////////////////////////////////////////////////////////////////////////

// Standard Library
#import "Basic";
#import "Compiler";
#import "String";
#import "File";

// Plugins
#import "Metaprogram_Plugins";
#import "Iprof";

plugins: [..] *Metaprogram_Plugin;

// Local Project Modules
#import "ctags";

#load "shaders/compile-shaders.jai";
#run compile_shaders();
