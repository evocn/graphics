PFN_vkCreateInstance :: #type (pCreateInfo: *VkInstanceCreateInfo, pAllocator: *VkAllocationCallbacks, pInstance: *VkInstance) -> VkResult #c_call;
PFN_vkDestroyInstance :: #type (instance: VkInstance, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkEnumeratePhysicalDevices :: #type (instance: VkInstance, pPhysicalDeviceCount: *u32, pPhysicalDevices: *VkPhysicalDevice) -> VkResult #c_call;
PFN_vkGetDeviceProcAddr :: #type (device: VkDevice, pName: *u8) -> PFN_vkVoidFunction #c_call;
PFN_vkGetInstanceProcAddr :: #type (instance: VkInstance, pName: *u8) -> PFN_vkVoidFunction #c_call;
PFN_vkGetPhysicalDeviceProperties :: #type (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceQueueFamilyProperties :: #type (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceMemoryProperties :: #type (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceFeatures :: #type (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures) -> void #c_call;
PFN_vkGetPhysicalDeviceFormatProperties :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceImageFormatProperties :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *VkImageFormatProperties) -> VkResult #c_call;
PFN_vkCreateDevice :: #type (physicalDevice: VkPhysicalDevice, pCreateInfo: *VkDeviceCreateInfo, pAllocator: *VkAllocationCallbacks, pDevice: *VkDevice) -> VkResult #c_call;
PFN_vkDestroyDevice :: #type (device: VkDevice, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkEnumerateInstanceVersion :: #type (pApiVersion: *u32) -> VkResult #c_call;
PFN_vkEnumerateInstanceLayerProperties :: #type (pPropertyCount: *u32, pProperties: *VkLayerProperties) -> VkResult #c_call;
PFN_vkEnumerateInstanceExtensionProperties :: #type (pLayerName: *u8, pPropertyCount: *u32, pProperties: *VkExtensionProperties) -> VkResult #c_call;
PFN_vkEnumerateDeviceLayerProperties :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkLayerProperties) -> VkResult #c_call;
PFN_vkEnumerateDeviceExtensionProperties :: #type (physicalDevice: VkPhysicalDevice, pLayerName: *u8, pPropertyCount: *u32, pProperties: *VkExtensionProperties) -> VkResult #c_call;
PFN_vkGetDeviceQueue :: #type (device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *VkQueue) -> void #c_call;
PFN_vkQueueSubmit :: #type (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo, fence: VkFence) -> VkResult #c_call;
PFN_vkQueueWaitIdle :: #type (queue: VkQueue) -> VkResult #c_call;
PFN_vkDeviceWaitIdle :: #type (device: VkDevice) -> VkResult #c_call;
PFN_vkAllocateMemory :: #type (device: VkDevice, pAllocateInfo: *VkMemoryAllocateInfo, pAllocator: *VkAllocationCallbacks, pMemory: *VkDeviceMemory) -> VkResult #c_call;
PFN_vkFreeMemory :: #type (device: VkDevice, memory: VkDeviceMemory, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkMapMemory :: #type (device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: **void) -> VkResult #c_call;
PFN_vkUnmapMemory :: #type (device: VkDevice, memory: VkDeviceMemory) -> void #c_call;
PFN_vkFlushMappedMemoryRanges :: #type (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) -> VkResult #c_call;
PFN_vkInvalidateMappedMemoryRanges :: #type (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) -> VkResult #c_call;
PFN_vkGetDeviceMemoryCommitment :: #type (device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *VkDeviceSize) -> void #c_call;
PFN_vkGetBufferMemoryRequirements :: #type (device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *VkMemoryRequirements) -> void #c_call;
PFN_vkBindBufferMemory :: #type (device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult #c_call;
PFN_vkGetImageMemoryRequirements :: #type (device: VkDevice, image: VkImage, pMemoryRequirements: *VkMemoryRequirements) -> void #c_call;
PFN_vkBindImageMemory :: #type (device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult #c_call;
PFN_vkGetImageSparseMemoryRequirements :: #type (device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements) -> void #c_call;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties) -> void #c_call;
PFN_vkQueueBindSparse :: #type (queue: VkQueue, bindInfoCount: u32, pBindInfo: *VkBindSparseInfo, fence: VkFence) -> VkResult #c_call;
PFN_vkCreateFence :: #type (device: VkDevice, pCreateInfo: *VkFenceCreateInfo, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) -> VkResult #c_call;
PFN_vkDestroyFence :: #type (device: VkDevice, fence: VkFence, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkResetFences :: #type (device: VkDevice, fenceCount: u32, pFences: *VkFence) -> VkResult #c_call;
PFN_vkGetFenceStatus :: #type (device: VkDevice, fence: VkFence) -> VkResult #c_call;
PFN_vkWaitForFences :: #type (device: VkDevice, fenceCount: u32, pFences: *VkFence, waitAll: VkBool32, timeout: u64) -> VkResult #c_call;
PFN_vkCreateSemaphore :: #type (device: VkDevice, pCreateInfo: *VkSemaphoreCreateInfo, pAllocator: *VkAllocationCallbacks, pSemaphore: *VkSemaphore) -> VkResult #c_call;
PFN_vkDestroySemaphore :: #type (device: VkDevice, semaphore: VkSemaphore, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateEvent :: #type (device: VkDevice, pCreateInfo: *VkEventCreateInfo, pAllocator: *VkAllocationCallbacks, pEvent: *VkEvent) -> VkResult #c_call;
PFN_vkDestroyEvent :: #type (device: VkDevice, event: VkEvent, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetEventStatus :: #type (device: VkDevice, event: VkEvent) -> VkResult #c_call;
PFN_vkSetEvent :: #type (device: VkDevice, event: VkEvent) -> VkResult #c_call;
PFN_vkResetEvent :: #type (device: VkDevice, event: VkEvent) -> VkResult #c_call;
PFN_vkCreateQueryPool :: #type (device: VkDevice, pCreateInfo: *VkQueryPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pQueryPool: *VkQueryPool) -> VkResult #c_call;
PFN_vkDestroyQueryPool :: #type (device: VkDevice, queryPool: VkQueryPool, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetQueryPoolResults :: #type (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: u64, pData: *void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> VkResult #c_call;
PFN_vkResetQueryPool :: #type (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> void #c_call;
PFN_vkResetQueryPoolEXT :: PFN_vkResetQueryPool;
PFN_vkCreateBuffer :: #type (device: VkDevice, pCreateInfo: *VkBufferCreateInfo, pAllocator: *VkAllocationCallbacks, pBuffer: *VkBuffer) -> VkResult #c_call;
PFN_vkDestroyBuffer :: #type (device: VkDevice, buffer: VkBuffer, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateBufferView :: #type (device: VkDevice, pCreateInfo: *VkBufferViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkBufferView) -> VkResult #c_call;
PFN_vkDestroyBufferView :: #type (device: VkDevice, bufferView: VkBufferView, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateImage :: #type (device: VkDevice, pCreateInfo: *VkImageCreateInfo, pAllocator: *VkAllocationCallbacks, pImage: *VkImage) -> VkResult #c_call;
PFN_vkDestroyImage :: #type (device: VkDevice, image: VkImage, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetImageSubresourceLayout :: #type (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource, pLayout: *VkSubresourceLayout) -> void #c_call;
PFN_vkCreateImageView :: #type (device: VkDevice, pCreateInfo: *VkImageViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkImageView) -> VkResult #c_call;
PFN_vkDestroyImageView :: #type (device: VkDevice, imageView: VkImageView, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateShaderModule :: #type (device: VkDevice, pCreateInfo: *VkShaderModuleCreateInfo, pAllocator: *VkAllocationCallbacks, pShaderModule: *VkShaderModule) -> VkResult #c_call;
PFN_vkDestroyShaderModule :: #type (device: VkDevice, shaderModule: VkShaderModule, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreatePipelineCache :: #type (device: VkDevice, pCreateInfo: *VkPipelineCacheCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineCache: *VkPipelineCache) -> VkResult #c_call;
PFN_vkDestroyPipelineCache :: #type (device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetPipelineCacheData :: #type (device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *u64, pData: *void) -> VkResult #c_call;
PFN_vkMergePipelineCaches :: #type (device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *VkPipelineCache) -> VkResult #c_call;
PFN_vkCreatePipelineBinariesKHR :: #type (device: VkDevice, pCreateInfo: *VkPipelineBinaryCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pBinaries: *VkPipelineBinaryHandlesInfoKHR) -> VkResult #c_call;
PFN_vkDestroyPipelineBinaryKHR :: #type (device: VkDevice, pipelineBinary: VkPipelineBinaryKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetPipelineKeyKHR :: #type (device: VkDevice, pPipelineCreateInfo: *VkPipelineCreateInfoKHR, pPipelineKey: *VkPipelineBinaryKeyKHR) -> VkResult #c_call;
PFN_vkGetPipelineBinaryDataKHR :: #type (device: VkDevice, pInfo: *VkPipelineBinaryDataInfoKHR, pPipelineBinaryKey: *VkPipelineBinaryKeyKHR, pPipelineBinaryDataSize: *u64, pPipelineBinaryData: *void) -> VkResult #c_call;
PFN_vkReleaseCapturedPipelineDataKHR :: #type (device: VkDevice, pInfo: *VkReleaseCapturedPipelineDataInfoKHR, pAllocator: *VkAllocationCallbacks) -> VkResult #c_call;
PFN_vkCreateGraphicsPipelines :: #type (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkGraphicsPipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkCreateComputePipelines :: #type (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkComputePipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI :: #type (device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *VkExtent2D) -> VkResult #c_call;
PFN_vkDestroyPipeline :: #type (device: VkDevice, pipeline: VkPipeline, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreatePipelineLayout :: #type (device: VkDevice, pCreateInfo: *VkPipelineLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineLayout: *VkPipelineLayout) -> VkResult #c_call;
PFN_vkDestroyPipelineLayout :: #type (device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateSampler :: #type (device: VkDevice, pCreateInfo: *VkSamplerCreateInfo, pAllocator: *VkAllocationCallbacks, pSampler: *VkSampler) -> VkResult #c_call;
PFN_vkDestroySampler :: #type (device: VkDevice, sampler: VkSampler, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateDescriptorSetLayout :: #type (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pSetLayout: *VkDescriptorSetLayout) -> VkResult #c_call;
PFN_vkDestroyDescriptorSetLayout :: #type (device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateDescriptorPool :: #type (device: VkDevice, pCreateInfo: *VkDescriptorPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorPool: *VkDescriptorPool) -> VkResult #c_call;
PFN_vkDestroyDescriptorPool :: #type (device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkResetDescriptorPool :: #type (device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> VkResult #c_call;
PFN_vkAllocateDescriptorSets :: #type (device: VkDevice, pAllocateInfo: *VkDescriptorSetAllocateInfo, pDescriptorSets: *VkDescriptorSet) -> VkResult #c_call;
PFN_vkFreeDescriptorSets :: #type (device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet) -> VkResult #c_call;
PFN_vkUpdateDescriptorSets :: #type (device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *VkCopyDescriptorSet) -> void #c_call;
PFN_vkCreateFramebuffer :: #type (device: VkDevice, pCreateInfo: *VkFramebufferCreateInfo, pAllocator: *VkAllocationCallbacks, pFramebuffer: *VkFramebuffer) -> VkResult #c_call;
PFN_vkDestroyFramebuffer :: #type (device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateRenderPass :: #type (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) -> VkResult #c_call;
PFN_vkDestroyRenderPass :: #type (device: VkDevice, renderPass: VkRenderPass, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetRenderAreaGranularity :: #type (device: VkDevice, renderPass: VkRenderPass, pGranularity: *VkExtent2D) -> void #c_call;
PFN_vkGetRenderingAreaGranularity :: #type (device: VkDevice, pRenderingAreaInfo: *VkRenderingAreaInfo, pGranularity: *VkExtent2D) -> void #c_call;
PFN_vkGetRenderingAreaGranularityKHR :: PFN_vkGetRenderingAreaGranularity;
PFN_vkCreateCommandPool :: #type (device: VkDevice, pCreateInfo: *VkCommandPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pCommandPool: *VkCommandPool) -> VkResult #c_call;
PFN_vkDestroyCommandPool :: #type (device: VkDevice, commandPool: VkCommandPool, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkResetCommandPool :: #type (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> VkResult #c_call;
PFN_vkAllocateCommandBuffers :: #type (device: VkDevice, pAllocateInfo: *VkCommandBufferAllocateInfo, pCommandBuffers: *VkCommandBuffer) -> VkResult #c_call;
PFN_vkFreeCommandBuffers :: #type (device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer) -> void #c_call;
PFN_vkBeginCommandBuffer :: #type (commandBuffer: VkCommandBuffer, pBeginInfo: *VkCommandBufferBeginInfo) -> VkResult #c_call;
PFN_vkEndCommandBuffer :: #type (commandBuffer: VkCommandBuffer) -> VkResult #c_call;
PFN_vkResetCommandBuffer :: #type (commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult #c_call;
PFN_vkCmdBindPipeline :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) -> void #c_call;
PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT :: #type (commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) -> void #c_call;
PFN_vkCmdSetViewport :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *VkViewport) -> void #c_call;
PFN_vkCmdSetScissor :: #type (commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *VkRect2D) -> void #c_call;
PFN_vkCmdSetLineWidth :: #type (commandBuffer: VkCommandBuffer, lineWidth: float) -> void #c_call;
PFN_vkCmdSetDepthBias :: #type (commandBuffer: VkCommandBuffer, depthBiasConstantFactor: float, depthBiasClamp: float, depthBiasSlopeFactor: float) -> void #c_call;
PFN_vkCmdSetBlendConstants :: #type (commandBuffer: VkCommandBuffer, blendConstants: /* [4] */*float) -> void #c_call;
PFN_vkCmdSetDepthBounds :: #type (commandBuffer: VkCommandBuffer, minDepthBounds: float, maxDepthBounds: float) -> void #c_call;
PFN_vkCmdSetStencilCompareMask :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) -> void #c_call;
PFN_vkCmdSetStencilWriteMask :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) -> void #c_call;
PFN_vkCmdSetStencilReference :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) -> void #c_call;
PFN_vkCmdBindDescriptorSets :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *u32) -> void #c_call;
PFN_vkCmdBindIndexBuffer :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) -> void #c_call;
PFN_vkCmdBindVertexBuffers :: #type (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdDraw :: #type (commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) -> void #c_call;
PFN_vkCmdDrawIndexed :: #type (commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: s32, firstInstance: u32) -> void #c_call;
PFN_vkCmdDrawMultiEXT :: #type (commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawMultiIndexedEXT :: #type (commandBuffer: VkCommandBuffer, drawCount: u32, pIndexInfo: *VkMultiDrawIndexedInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32, pVertexOffset: *s32) -> void #c_call;
PFN_vkCmdDrawIndirect :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawIndexedIndirect :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDispatch :: #type (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkCmdDispatchIndirect :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) -> void #c_call;
PFN_vkCmdSubpassShadingHUAWEI :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdDrawClusterHUAWEI :: #type (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkCmdDrawClusterIndirectHUAWEI :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) -> void #c_call;
PFN_vkCmdUpdatePipelineIndirectBufferNV :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) -> void #c_call;
PFN_vkCmdCopyBuffer :: #type (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferCopy) -> void #c_call;
PFN_vkCmdCopyImage :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageCopy) -> void #c_call;
PFN_vkCmdBlitImage :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageBlit, filter: VkFilter) -> void #c_call;
PFN_vkCmdCopyBufferToImage :: #type (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkBufferImageCopy) -> void #c_call;
PFN_vkCmdCopyImageToBuffer :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferImageCopy) -> void #c_call;
PFN_vkCmdCopyMemoryIndirectNV :: #type (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdCopyMemoryToImageIndirectNV :: #type (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32, dstImage: VkImage, dstImageLayout: VkImageLayout, pImageSubresources: *VkImageSubresourceLayers) -> void #c_call;
PFN_vkCmdUpdateBuffer :: #type (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *void) -> void #c_call;
PFN_vkCmdFillBuffer :: #type (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) -> void #c_call;
PFN_vkCmdClearColorImage :: #type (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *VkClearColorValue, rangeCount: u32, pRanges: *VkImageSubresourceRange) -> void #c_call;
PFN_vkCmdClearDepthStencilImage :: #type (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *VkClearDepthStencilValue, rangeCount: u32, pRanges: *VkImageSubresourceRange) -> void #c_call;
PFN_vkCmdClearAttachments :: #type (commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *VkClearAttachment, rectCount: u32, pRects: *VkClearRect) -> void #c_call;
PFN_vkCmdResolveImage :: #type (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageResolve) -> void #c_call;
PFN_vkCmdSetEvent :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> void #c_call;
PFN_vkCmdResetEvent :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> void #c_call;
PFN_vkCmdWaitEvents :: #type (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier) -> void #c_call;
PFN_vkCmdPipelineBarrier :: #type (commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier) -> void #c_call;
PFN_vkCmdBeginQuery :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) -> void #c_call;
PFN_vkCmdEndQuery :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) -> void #c_call;
PFN_vkCmdBeginConditionalRenderingEXT :: #type (commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *VkConditionalRenderingBeginInfoEXT) -> void #c_call;
PFN_vkCmdEndConditionalRenderingEXT :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdResetQueryPool :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> void #c_call;
PFN_vkCmdWriteTimestamp :: #type (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) -> void #c_call;
PFN_vkCmdCopyQueryPoolResults :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) -> void #c_call;
PFN_vkCmdPushConstants :: #type (commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *void) -> void #c_call;
PFN_vkCmdBeginRenderPass :: #type (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, contents: VkSubpassContents) -> void #c_call;
PFN_vkCmdNextSubpass :: #type (commandBuffer: VkCommandBuffer, contents: VkSubpassContents) -> void #c_call;
PFN_vkCmdEndRenderPass :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdExecuteCommands :: #type (commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer) -> void #c_call;
PFN_vkCreateAndroidSurfaceKHR :: #type (instance: VkInstance, pCreateInfo: *VkAndroidSurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceDisplayPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPropertiesKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlanePropertiesKHR) -> VkResult #c_call;
PFN_vkGetDisplayPlaneSupportedDisplaysKHR :: #type (physicalDevice: VkPhysicalDevice, planeIndex: u32, pDisplayCount: *u32, pDisplays: *VkDisplayKHR) -> VkResult #c_call;
PFN_vkGetDisplayModePropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModePropertiesKHR) -> VkResult #c_call;
PFN_vkCreateDisplayModeKHR :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: *VkDisplayModeCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pMode: *VkDisplayModeKHR) -> VkResult #c_call;
PFN_vkGetDisplayPlaneCapabilitiesKHR :: #type (physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: u32, pCapabilities: *VkDisplayPlaneCapabilitiesKHR) -> VkResult #c_call;
PFN_vkCreateDisplayPlaneSurfaceKHR :: #type (instance: VkInstance, pCreateInfo: *VkDisplaySurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkCreateSharedSwapchainsKHR :: #type (device: VkDevice, swapchainCount: u32, pCreateInfos: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchains: *VkSwapchainKHR) -> VkResult #c_call;
PFN_vkDestroySurfaceKHR :: #type (instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetPhysicalDeviceSurfaceSupportKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, surface: VkSurfaceKHR, pSupported: *VkBool32) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilitiesKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfaceFormatsKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormatKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfacePresentModesKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: *u32, pPresentModes: *VkPresentModeKHR) -> VkResult #c_call;
PFN_vkCreateSwapchainKHR :: #type (device: VkDevice, pCreateInfo: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchain: *VkSwapchainKHR) -> VkResult #c_call;
PFN_vkDestroySwapchainKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetSwapchainImagesKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: *u32, pSwapchainImages: *VkImage) -> VkResult #c_call;
PFN_vkAcquireNextImageKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, timeout: u64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: *u32) -> VkResult #c_call;
PFN_vkQueuePresentKHR :: #type (queue: VkQueue, pPresentInfo: *VkPresentInfoKHR) -> VkResult #c_call;
PFN_vkCreateViSurfaceNN :: #type (instance: VkInstance, pCreateInfo: *VkViSurfaceCreateInfoNN, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkCreateWaylandSurfaceKHR :: #type (instance: VkInstance, pCreateInfo: *VkWaylandSurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, display: *wl_display) -> VkBool32 #c_call;
PFN_vkCreateWin32SurfaceKHR :: #type (instance: VkInstance, pCreateInfo: *VkWin32SurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32) -> VkBool32 #c_call;
PFN_vkCreateXlibSurfaceKHR :: #type (instance: VkInstance, pCreateInfo: *VkXlibSurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, dpy: *Display, visualID: VisualID) -> VkBool32 #c_call;
PFN_vkCreateXcbSurfaceKHR :: #type (instance: VkInstance, pCreateInfo: *VkXcbSurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, connection: *xcb_connection_t, visual_id: xcb_visualid_t) -> VkBool32 #c_call;
PFN_vkCreateDirectFBSurfaceEXT :: #type (instance: VkInstance, pCreateInfo: *VkDirectFBSurfaceCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, dfb: *IDirectFB) -> VkBool32 #c_call;
PFN_vkCreateImagePipeSurfaceFUCHSIA :: #type (instance: VkInstance, pCreateInfo: *VkImagePipeSurfaceCreateInfoFUCHSIA, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkCreateStreamDescriptorSurfaceGGP :: #type (instance: VkInstance, pCreateInfo: *VkStreamDescriptorSurfaceCreateInfoGGP, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkCreateScreenSurfaceQNX :: #type (instance: VkInstance, pCreateInfo: *VkScreenSurfaceCreateInfoQNX, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, window: *_screen_window) -> VkBool32 #c_call;
PFN_vkCreateDebugReportCallbackEXT :: #type (instance: VkInstance, pCreateInfo: *VkDebugReportCallbackCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pCallback: *VkDebugReportCallbackEXT) -> VkResult #c_call;
PFN_vkDestroyDebugReportCallbackEXT :: #type (instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDebugReportMessageEXT :: #type (instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: u64, messageCode: s32, pLayerPrefix: *u8, pMessage: *u8) -> void #c_call;
PFN_vkDebugMarkerSetObjectNameEXT :: #type (device: VkDevice, pNameInfo: *VkDebugMarkerObjectNameInfoEXT) -> VkResult #c_call;
PFN_vkDebugMarkerSetObjectTagEXT :: #type (device: VkDevice, pTagInfo: *VkDebugMarkerObjectTagInfoEXT) -> VkResult #c_call;
PFN_vkCmdDebugMarkerBeginEXT :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT) -> void #c_call;
PFN_vkCmdDebugMarkerEndEXT :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdDebugMarkerInsertEXT :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT) -> void #c_call;
PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *VkExternalImageFormatPropertiesNV) -> VkResult #c_call;
PFN_vkGetMemoryWin32HandleNV :: #type (device: VkDevice, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagsNV, pHandle: *HANDLE) -> VkResult #c_call;
PFN_vkCmdExecuteGeneratedCommandsNV :: #type (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoNV) -> void #c_call;
PFN_vkCmdPreprocessGeneratedCommandsNV :: #type (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoNV) -> void #c_call;
PFN_vkCmdBindPipelineShaderGroupNV :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, groupIndex: u32) -> void #c_call;
PFN_vkGetGeneratedCommandsMemoryRequirementsNV :: #type (device: VkDevice, pInfo: *VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkCreateIndirectCommandsLayoutNV :: #type (device: VkDevice, pCreateInfo: *VkIndirectCommandsLayoutCreateInfoNV, pAllocator: *VkAllocationCallbacks, pIndirectCommandsLayout: *VkIndirectCommandsLayoutNV) -> VkResult #c_call;
PFN_vkDestroyIndirectCommandsLayoutNV :: #type (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdExecuteGeneratedCommandsEXT :: #type (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoEXT) -> void #c_call;
PFN_vkCmdPreprocessGeneratedCommandsEXT :: #type (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoEXT, stateCommandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkGetGeneratedCommandsMemoryRequirementsEXT :: #type (device: VkDevice, pInfo: *VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkCreateIndirectCommandsLayoutEXT :: #type (device: VkDevice, pCreateInfo: *VkIndirectCommandsLayoutCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pIndirectCommandsLayout: *VkIndirectCommandsLayoutEXT) -> VkResult #c_call;
PFN_vkDestroyIndirectCommandsLayoutEXT :: #type (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateIndirectExecutionSetEXT :: #type (device: VkDevice, pCreateInfo: *VkIndirectExecutionSetCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pIndirectExecutionSet: *VkIndirectExecutionSetEXT) -> VkResult #c_call;
PFN_vkDestroyIndirectExecutionSetEXT :: #type (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkUpdateIndirectExecutionSetPipelineEXT :: #type (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: u32, pExecutionSetWrites: *VkWriteIndirectExecutionSetPipelineEXT) -> void #c_call;
PFN_vkUpdateIndirectExecutionSetShaderEXT :: #type (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: u32, pExecutionSetWrites: *VkWriteIndirectExecutionSetShaderEXT) -> void #c_call;
PFN_vkGetPhysicalDeviceFeatures2 :: #type (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures2) -> void #c_call;
PFN_vkGetPhysicalDeviceFeatures2KHR :: PFN_vkGetPhysicalDeviceFeatures2;
PFN_vkGetPhysicalDeviceProperties2 :: #type (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceProperties2KHR :: PFN_vkGetPhysicalDeviceProperties2;
PFN_vkGetPhysicalDeviceFormatProperties2 :: #type (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceFormatProperties2KHR :: PFN_vkGetPhysicalDeviceFormatProperties2;
PFN_vkGetPhysicalDeviceImageFormatProperties2 :: #type (physicalDevice: VkPhysicalDevice, pImageFormatInfo: *VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *VkImageFormatProperties2) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceImageFormatProperties2KHR :: PFN_vkGetPhysicalDeviceImageFormatProperties2;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2 :: #type (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR :: PFN_vkGetPhysicalDeviceQueueFamilyProperties2;
PFN_vkGetPhysicalDeviceMemoryProperties2 :: #type (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceMemoryProperties2KHR :: PFN_vkGetPhysicalDeviceMemoryProperties2;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 :: #type (physicalDevice: VkPhysicalDevice, pFormatInfo: *VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties2) -> void #c_call;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: PFN_vkGetPhysicalDeviceSparseImageFormatProperties2;
PFN_vkCmdPushDescriptorSet :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet) -> void #c_call;
PFN_vkCmdPushDescriptorSetKHR :: PFN_vkCmdPushDescriptorSet;
PFN_vkTrimCommandPool :: #type (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> void #c_call;
PFN_vkTrimCommandPoolKHR :: PFN_vkTrimCommandPool;
PFN_vkGetPhysicalDeviceExternalBufferProperties :: #type (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *VkExternalBufferProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR :: PFN_vkGetPhysicalDeviceExternalBufferProperties;
PFN_vkGetMemoryWin32HandleKHR :: #type (device: VkDevice, pGetWin32HandleInfo: *VkMemoryGetWin32HandleInfoKHR, pHandle: *HANDLE) -> VkResult #c_call;
PFN_vkGetMemoryWin32HandlePropertiesKHR :: #type (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, handle: HANDLE, pMemoryWin32HandleProperties: *VkMemoryWin32HandlePropertiesKHR) -> VkResult #c_call;
PFN_vkGetMemoryFdKHR :: #type (device: VkDevice, pGetFdInfo: *VkMemoryGetFdInfoKHR, pFd: *int) -> VkResult #c_call;
PFN_vkGetMemoryFdPropertiesKHR :: #type (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: int, pMemoryFdProperties: *VkMemoryFdPropertiesKHR) -> VkResult #c_call;
PFN_vkGetMemoryZirconHandleFUCHSIA :: #type (device: VkDevice, pGetZirconHandleInfo: *VkMemoryGetZirconHandleInfoFUCHSIA, pZirconHandle: *zx_handle_t) -> VkResult #c_call;
PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA :: #type (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, zirconHandle: zx_handle_t, pMemoryZirconHandleProperties: *VkMemoryZirconHandlePropertiesFUCHSIA) -> VkResult #c_call;
PFN_vkGetMemoryRemoteAddressNV :: #type (device: VkDevice, pMemoryGetRemoteAddressInfo: *VkMemoryGetRemoteAddressInfoNV, pAddress: *VkRemoteAddressNV) -> VkResult #c_call;
PFN_vkGetMemorySciBufNV :: #type (device: VkDevice, pGetSciBufInfo: *VkMemoryGetSciBufInfoNV, pHandle: *NvSciBufObj) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV :: #type (physicalDevice: VkPhysicalDevice, handleType: VkExternalMemoryHandleTypeFlagBits, handle: NvSciBufObj, pMemorySciBufProperties: *VkMemorySciBufPropertiesNV) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSciBufAttributesNV :: #type (physicalDevice: VkPhysicalDevice, pAttributes: NvSciBufAttrList) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceExternalSemaphoreProperties :: #type (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *VkExternalSemaphoreProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: PFN_vkGetPhysicalDeviceExternalSemaphoreProperties;
PFN_vkGetSemaphoreWin32HandleKHR :: #type (device: VkDevice, pGetWin32HandleInfo: *VkSemaphoreGetWin32HandleInfoKHR, pHandle: *HANDLE) -> VkResult #c_call;
PFN_vkImportSemaphoreWin32HandleKHR :: #type (device: VkDevice, pImportSemaphoreWin32HandleInfo: *VkImportSemaphoreWin32HandleInfoKHR) -> VkResult #c_call;
PFN_vkGetSemaphoreFdKHR :: #type (device: VkDevice, pGetFdInfo: *VkSemaphoreGetFdInfoKHR, pFd: *int) -> VkResult #c_call;
PFN_vkImportSemaphoreFdKHR :: #type (device: VkDevice, pImportSemaphoreFdInfo: *VkImportSemaphoreFdInfoKHR) -> VkResult #c_call;
PFN_vkGetSemaphoreZirconHandleFUCHSIA :: #type (device: VkDevice, pGetZirconHandleInfo: *VkSemaphoreGetZirconHandleInfoFUCHSIA, pZirconHandle: *zx_handle_t) -> VkResult #c_call;
PFN_vkImportSemaphoreZirconHandleFUCHSIA :: #type (device: VkDevice, pImportSemaphoreZirconHandleInfo: *VkImportSemaphoreZirconHandleInfoFUCHSIA) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceExternalFenceProperties :: #type (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *VkExternalFenceProperties) -> void #c_call;
PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR :: PFN_vkGetPhysicalDeviceExternalFenceProperties;
PFN_vkGetFenceWin32HandleKHR :: #type (device: VkDevice, pGetWin32HandleInfo: *VkFenceGetWin32HandleInfoKHR, pHandle: *HANDLE) -> VkResult #c_call;
PFN_vkImportFenceWin32HandleKHR :: #type (device: VkDevice, pImportFenceWin32HandleInfo: *VkImportFenceWin32HandleInfoKHR) -> VkResult #c_call;
PFN_vkGetFenceFdKHR :: #type (device: VkDevice, pGetFdInfo: *VkFenceGetFdInfoKHR, pFd: *int) -> VkResult #c_call;
PFN_vkImportFenceFdKHR :: #type (device: VkDevice, pImportFenceFdInfo: *VkImportFenceFdInfoKHR) -> VkResult #c_call;
PFN_vkGetFenceSciSyncFenceNV :: #type (device: VkDevice, pGetSciSyncHandleInfo: *VkFenceGetSciSyncInfoNV, pHandle: *void) -> VkResult #c_call;
PFN_vkGetFenceSciSyncObjNV :: #type (device: VkDevice, pGetSciSyncHandleInfo: *VkFenceGetSciSyncInfoNV, pHandle: *void) -> VkResult #c_call;
PFN_vkImportFenceSciSyncFenceNV :: #type (device: VkDevice, pImportFenceSciSyncInfo: *VkImportFenceSciSyncInfoNV) -> VkResult #c_call;
PFN_vkImportFenceSciSyncObjNV :: #type (device: VkDevice, pImportFenceSciSyncInfo: *VkImportFenceSciSyncInfoNV) -> VkResult #c_call;
PFN_vkGetSemaphoreSciSyncObjNV :: #type (device: VkDevice, pGetSciSyncInfo: *VkSemaphoreGetSciSyncInfoNV, pHandle: *void) -> VkResult #c_call;
PFN_vkImportSemaphoreSciSyncObjNV :: #type (device: VkDevice, pImportSemaphoreSciSyncInfo: *VkImportSemaphoreSciSyncInfoNV) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSciSyncAttributesNV :: #type (physicalDevice: VkPhysicalDevice, pSciSyncAttributesInfo: *VkSciSyncAttributesInfoNV, pAttributes: NvSciSyncAttrList) -> VkResult #c_call;
PFN_vkCreateSemaphoreSciSyncPoolNV :: #type (device: VkDevice, pCreateInfo: *VkSemaphoreSciSyncPoolCreateInfoNV, pAllocator: *VkAllocationCallbacks, pSemaphorePool: *VkSemaphoreSciSyncPoolNV) -> VkResult #c_call;
PFN_vkDestroySemaphoreSciSyncPoolNV :: #type (device: VkDevice, semaphorePool: VkSemaphoreSciSyncPoolNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkReleaseDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult #c_call;
PFN_vkAcquireXlibDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, dpy: *Display, display: VkDisplayKHR) -> VkResult #c_call;
PFN_vkGetRandROutputDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, dpy: *Display, rrOutput: RROutput, pDisplay: *VkDisplayKHR) -> VkResult #c_call;
PFN_vkAcquireWinrtDisplayNV :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult #c_call;
PFN_vkGetWinrtDisplayNV :: #type (physicalDevice: VkPhysicalDevice, deviceRelativeId: u32, pDisplay: *VkDisplayKHR) -> VkResult #c_call;
PFN_vkDisplayPowerControlEXT :: #type (device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *VkDisplayPowerInfoEXT) -> VkResult #c_call;
PFN_vkRegisterDeviceEventEXT :: #type (device: VkDevice, pDeviceEventInfo: *VkDeviceEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) -> VkResult #c_call;
PFN_vkRegisterDisplayEventEXT :: #type (device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: *VkDisplayEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) -> VkResult #c_call;
PFN_vkGetSwapchainCounterEXT :: #type (device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: *u64) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilities2EXT) -> VkResult #c_call;
PFN_vkEnumeratePhysicalDeviceGroups :: #type (instance: VkInstance, pPhysicalDeviceGroupCount: *u32, pPhysicalDeviceGroupProperties: *VkPhysicalDeviceGroupProperties) -> VkResult #c_call;
PFN_vkEnumeratePhysicalDeviceGroupsKHR :: PFN_vkEnumeratePhysicalDeviceGroups;
PFN_vkGetDeviceGroupPeerMemoryFeatures :: #type (device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags) -> void #c_call;
PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR :: PFN_vkGetDeviceGroupPeerMemoryFeatures;
PFN_vkBindBufferMemory2 :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindBufferMemoryInfo) -> VkResult #c_call;
PFN_vkBindBufferMemory2KHR :: PFN_vkBindBufferMemory2;
PFN_vkBindImageMemory2 :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindImageMemoryInfo) -> VkResult #c_call;
PFN_vkBindImageMemory2KHR :: PFN_vkBindImageMemory2;
PFN_vkCmdSetDeviceMask :: #type (commandBuffer: VkCommandBuffer, deviceMask: u32) -> void #c_call;
PFN_vkCmdSetDeviceMaskKHR :: PFN_vkCmdSetDeviceMask;
PFN_vkGetDeviceGroupPresentCapabilitiesKHR :: #type (device: VkDevice, pDeviceGroupPresentCapabilities: *VkDeviceGroupPresentCapabilitiesKHR) -> VkResult #c_call;
PFN_vkGetDeviceGroupSurfacePresentModesKHR :: #type (device: VkDevice, surface: VkSurfaceKHR, pModes: *VkDeviceGroupPresentModeFlagsKHR) -> VkResult #c_call;
PFN_vkAcquireNextImage2KHR :: #type (device: VkDevice, pAcquireInfo: *VkAcquireNextImageInfoKHR, pImageIndex: *u32) -> VkResult #c_call;
PFN_vkCmdDispatchBase :: #type (commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkCmdDispatchBaseKHR :: PFN_vkCmdDispatchBase;
PFN_vkGetPhysicalDevicePresentRectanglesKHR :: #type (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: *u32, pRects: *VkRect2D) -> VkResult #c_call;
PFN_vkCreateDescriptorUpdateTemplate :: #type (device: VkDevice, pCreateInfo: *VkDescriptorUpdateTemplateCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate) -> VkResult #c_call;
PFN_vkCreateDescriptorUpdateTemplateKHR :: PFN_vkCreateDescriptorUpdateTemplate;
PFN_vkDestroyDescriptorUpdateTemplate :: #type (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDestroyDescriptorUpdateTemplateKHR :: PFN_vkDestroyDescriptorUpdateTemplate;
PFN_vkUpdateDescriptorSetWithTemplate :: #type (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *void) -> void #c_call;
PFN_vkUpdateDescriptorSetWithTemplateKHR :: PFN_vkUpdateDescriptorSetWithTemplate;
PFN_vkCmdPushDescriptorSetWithTemplate :: #type (commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *void) -> void #c_call;
PFN_vkCmdPushDescriptorSetWithTemplateKHR :: PFN_vkCmdPushDescriptorSetWithTemplate;
PFN_vkSetHdrMetadataEXT :: #type (device: VkDevice, swapchainCount: u32, pSwapchains: *VkSwapchainKHR, pMetadata: *VkHdrMetadataEXT) -> void #c_call;
PFN_vkGetSwapchainStatusKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult #c_call;
PFN_vkGetRefreshCycleDurationGOOGLE :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *VkRefreshCycleDurationGOOGLE) -> VkResult #c_call;
PFN_vkGetPastPresentationTimingGOOGLE :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: *u32, pPresentationTimings: *VkPastPresentationTimingGOOGLE) -> VkResult #c_call;
PFN_vkCreateIOSSurfaceMVK :: #type (instance: VkInstance, pCreateInfo: *VkIOSSurfaceCreateInfoMVK, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkCreateMacOSSurfaceMVK :: #type (instance: VkInstance, pCreateInfo: *VkMacOSSurfaceCreateInfoMVK, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkCreateMetalSurfaceEXT :: #type (instance: VkInstance, pCreateInfo: *VkMetalSurfaceCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkCmdSetViewportWScalingNV :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *VkViewportWScalingNV) -> void #c_call;
PFN_vkCmdSetDiscardRectangleEXT :: #type (commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *VkRect2D) -> void #c_call;
PFN_vkCmdSetDiscardRectangleEnableEXT :: #type (commandBuffer: VkCommandBuffer, discardRectangleEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDiscardRectangleModeEXT :: #type (commandBuffer: VkCommandBuffer, discardRectangleMode: VkDiscardRectangleModeEXT) -> void #c_call;
PFN_vkCmdSetSampleLocationsEXT :: #type (commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *VkSampleLocationsInfoEXT) -> void #c_call;
PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT :: #type (physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: *VkMultisamplePropertiesEXT) -> void #c_call;
PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR :: #type (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *VkSurfaceCapabilities2KHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfaceFormats2KHR :: #type (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormat2KHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceDisplayProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayProperties2KHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlaneProperties2KHR) -> VkResult #c_call;
PFN_vkGetDisplayModeProperties2KHR :: #type (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModeProperties2KHR) -> VkResult #c_call;
PFN_vkGetDisplayPlaneCapabilities2KHR :: #type (physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: *VkDisplayPlaneInfo2KHR, pCapabilities: *VkDisplayPlaneCapabilities2KHR) -> VkResult #c_call;
PFN_vkGetBufferMemoryRequirements2 :: #type (device: VkDevice, pInfo: *VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetBufferMemoryRequirements2KHR :: PFN_vkGetBufferMemoryRequirements2;
PFN_vkGetImageMemoryRequirements2 :: #type (device: VkDevice, pInfo: *VkImageMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetImageMemoryRequirements2KHR :: PFN_vkGetImageMemoryRequirements2;
PFN_vkGetImageSparseMemoryRequirements2 :: #type (device: VkDevice, pInfo: *VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) -> void #c_call;
PFN_vkGetImageSparseMemoryRequirements2KHR :: PFN_vkGetImageSparseMemoryRequirements2;
PFN_vkGetDeviceBufferMemoryRequirements :: #type (device: VkDevice, pInfo: *VkDeviceBufferMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetDeviceBufferMemoryRequirementsKHR :: PFN_vkGetDeviceBufferMemoryRequirements;
PFN_vkGetDeviceImageMemoryRequirements :: #type (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetDeviceImageMemoryRequirementsKHR :: PFN_vkGetDeviceImageMemoryRequirements;
PFN_vkGetDeviceImageSparseMemoryRequirements :: #type (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) -> void #c_call;
PFN_vkGetDeviceImageSparseMemoryRequirementsKHR :: PFN_vkGetDeviceImageSparseMemoryRequirements;
PFN_vkCreateSamplerYcbcrConversion :: #type (device: VkDevice, pCreateInfo: *VkSamplerYcbcrConversionCreateInfo, pAllocator: *VkAllocationCallbacks, pYcbcrConversion: *VkSamplerYcbcrConversion) -> VkResult #c_call;
PFN_vkCreateSamplerYcbcrConversionKHR :: PFN_vkCreateSamplerYcbcrConversion;
PFN_vkDestroySamplerYcbcrConversion :: #type (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDestroySamplerYcbcrConversionKHR :: PFN_vkDestroySamplerYcbcrConversion;
PFN_vkGetDeviceQueue2 :: #type (device: VkDevice, pQueueInfo: *VkDeviceQueueInfo2, pQueue: *VkQueue) -> void #c_call;
PFN_vkCreateValidationCacheEXT :: #type (device: VkDevice, pCreateInfo: *VkValidationCacheCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pValidationCache: *VkValidationCacheEXT) -> VkResult #c_call;
PFN_vkDestroyValidationCacheEXT :: #type (device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetValidationCacheDataEXT :: #type (device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: *u64, pData: *void) -> VkResult #c_call;
PFN_vkMergeValidationCachesEXT :: #type (device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *VkValidationCacheEXT) -> VkResult #c_call;
PFN_vkGetDescriptorSetLayoutSupport :: #type (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pSupport: *VkDescriptorSetLayoutSupport) -> void #c_call;
PFN_vkGetDescriptorSetLayoutSupportKHR :: PFN_vkGetDescriptorSetLayoutSupport;
PFN_vkGetSwapchainGrallocUsageANDROID :: #type (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, grallocUsage: *int) -> VkResult #c_call;
PFN_vkGetSwapchainGrallocUsage2ANDROID :: #type (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, swapchainImageUsage: VkSwapchainImageUsageFlagsANDROID, grallocConsumerUsage: *u64, grallocProducerUsage: *u64) -> VkResult #c_call;
PFN_vkAcquireImageANDROID :: #type (device: VkDevice, image: VkImage, nativeFenceFd: int, semaphore: VkSemaphore, fence: VkFence) -> VkResult #c_call;
PFN_vkQueueSignalReleaseImageANDROID :: #type (queue: VkQueue, waitSemaphoreCount: u32, pWaitSemaphores: *VkSemaphore, image: VkImage, pNativeFenceFd: *int) -> VkResult #c_call;
PFN_vkGetShaderInfoAMD :: #type (device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *u64, pInfo: *void) -> VkResult #c_call;
PFN_vkSetLocalDimmingAMD :: #type (device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) -> void #c_call;
PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR :: #type (physicalDevice: VkPhysicalDevice, pTimeDomainCount: *u32, pTimeDomains: *VkTimeDomainKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
PFN_vkGetCalibratedTimestampsKHR :: #type (device: VkDevice, timestampCount: u32, pTimestampInfos: *VkCalibratedTimestampInfoKHR, pTimestamps: *u64, pMaxDeviation: *u64) -> VkResult #c_call;
PFN_vkGetCalibratedTimestampsEXT :: PFN_vkGetCalibratedTimestampsKHR;
PFN_vkSetDebugUtilsObjectNameEXT :: #type (device: VkDevice, pNameInfo: *VkDebugUtilsObjectNameInfoEXT) -> VkResult #c_call;
PFN_vkSetDebugUtilsObjectTagEXT :: #type (device: VkDevice, pTagInfo: *VkDebugUtilsObjectTagInfoEXT) -> VkResult #c_call;
PFN_vkQueueBeginDebugUtilsLabelEXT :: #type (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkQueueEndDebugUtilsLabelEXT :: #type (queue: VkQueue) -> void #c_call;
PFN_vkQueueInsertDebugUtilsLabelEXT :: #type (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkCmdBeginDebugUtilsLabelEXT :: #type (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkCmdEndDebugUtilsLabelEXT :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdInsertDebugUtilsLabelEXT :: #type (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT) -> void #c_call;
PFN_vkCreateDebugUtilsMessengerEXT :: #type (instance: VkInstance, pCreateInfo: *VkDebugUtilsMessengerCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pMessenger: *VkDebugUtilsMessengerEXT) -> VkResult #c_call;
PFN_vkDestroyDebugUtilsMessengerEXT :: #type (instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkSubmitDebugUtilsMessageEXT :: #type (instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *VkDebugUtilsMessengerCallbackDataEXT) -> void #c_call;
PFN_vkGetMemoryHostPointerPropertiesEXT :: #type (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *void, pMemoryHostPointerProperties: *VkMemoryHostPointerPropertiesEXT) -> VkResult #c_call;
PFN_vkCmdWriteBufferMarkerAMD :: #type (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) -> void #c_call;
PFN_vkCreateRenderPass2 :: #type (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo2, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) -> VkResult #c_call;
PFN_vkCreateRenderPass2KHR :: PFN_vkCreateRenderPass2;
PFN_vkCmdBeginRenderPass2 :: #type (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, pSubpassBeginInfo: *VkSubpassBeginInfo) -> void #c_call;
PFN_vkCmdBeginRenderPass2KHR :: PFN_vkCmdBeginRenderPass2;
PFN_vkCmdNextSubpass2 :: #type (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *VkSubpassBeginInfo, pSubpassEndInfo: *VkSubpassEndInfo) -> void #c_call;
PFN_vkCmdNextSubpass2KHR :: PFN_vkCmdNextSubpass2;
PFN_vkCmdEndRenderPass2 :: #type (commandBuffer: VkCommandBuffer, pSubpassEndInfo: *VkSubpassEndInfo) -> void #c_call;
PFN_vkCmdEndRenderPass2KHR :: PFN_vkCmdEndRenderPass2;
PFN_vkGetSemaphoreCounterValue :: #type (device: VkDevice, semaphore: VkSemaphore, pValue: *u64) -> VkResult #c_call;
PFN_vkGetSemaphoreCounterValueKHR :: PFN_vkGetSemaphoreCounterValue;
PFN_vkWaitSemaphores :: #type (device: VkDevice, pWaitInfo: *VkSemaphoreWaitInfo, timeout: u64) -> VkResult #c_call;
PFN_vkWaitSemaphoresKHR :: PFN_vkWaitSemaphores;
PFN_vkSignalSemaphore :: #type (device: VkDevice, pSignalInfo: *VkSemaphoreSignalInfo) -> VkResult #c_call;
PFN_vkSignalSemaphoreKHR :: PFN_vkSignalSemaphore;
PFN_vkGetAndroidHardwareBufferPropertiesANDROID :: #type (device: VkDevice, buffer: *AHardwareBuffer, pProperties: *VkAndroidHardwareBufferPropertiesANDROID) -> VkResult #c_call;
PFN_vkGetMemoryAndroidHardwareBufferANDROID :: #type (device: VkDevice, pInfo: *VkMemoryGetAndroidHardwareBufferInfoANDROID, pBuffer: **AHardwareBuffer) -> VkResult #c_call;
PFN_vkCmdDrawIndirectCount :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawIndirectCountKHR :: PFN_vkCmdDrawIndirectCount;
PFN_vkCmdDrawIndirectCountAMD :: PFN_vkCmdDrawIndirectCount;
PFN_vkCmdDrawIndexedIndirectCount :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawIndexedIndirectCountKHR :: PFN_vkCmdDrawIndexedIndirectCount;
PFN_vkCmdDrawIndexedIndirectCountAMD :: PFN_vkCmdDrawIndexedIndirectCount;
PFN_vkCmdSetCheckpointNV :: #type (commandBuffer: VkCommandBuffer, pCheckpointMarker: *void) -> void #c_call;
PFN_vkGetQueueCheckpointDataNV :: #type (queue: VkQueue, pCheckpointDataCount: *u32, pCheckpointData: *VkCheckpointDataNV) -> void #c_call;
PFN_vkCmdBindTransformFeedbackBuffersEXT :: #type (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize) -> void #c_call;
PFN_vkCmdBeginTransformFeedbackEXT :: #type (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdEndTransformFeedbackEXT :: #type (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdBeginQueryIndexedEXT :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags, index: u32) -> void #c_call;
PFN_vkCmdEndQueryIndexedEXT :: #type (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, index: u32) -> void #c_call;
PFN_vkCmdDrawIndirectByteCountEXT :: #type (commandBuffer: VkCommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: u32, vertexStride: u32) -> void #c_call;
PFN_vkCmdSetExclusiveScissorNV :: #type (commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *VkRect2D) -> void #c_call;
PFN_vkCmdSetExclusiveScissorEnableNV :: #type (commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *VkBool32) -> void #c_call;
PFN_vkCmdBindShadingRateImageNV :: #type (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> void #c_call;
PFN_vkCmdSetViewportShadingRatePaletteNV :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *VkShadingRatePaletteNV) -> void #c_call;
PFN_vkCmdSetCoarseSampleOrderNV :: #type (commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *VkCoarseSampleOrderCustomNV) -> void #c_call;
PFN_vkCmdDrawMeshTasksNV :: #type (commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectNV :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectCountNV :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksEXT :: #type (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectEXT :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> void #c_call;
PFN_vkCmdDrawMeshTasksIndirectCountEXT :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> void #c_call;
PFN_vkCompileDeferredNV :: #type (device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult #c_call;
PFN_vkCreateAccelerationStructureNV :: #type (device: VkDevice, pCreateInfo: *VkAccelerationStructureCreateInfoNV, pAllocator: *VkAllocationCallbacks, pAccelerationStructure: *VkAccelerationStructureNV) -> VkResult #c_call;
PFN_vkCmdBindInvocationMaskHUAWEI :: #type (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> void #c_call;
PFN_vkDestroyAccelerationStructureKHR :: #type (device: VkDevice, accelerationStructure: VkAccelerationStructureKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDestroyAccelerationStructureNV :: #type (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetAccelerationStructureMemoryRequirementsNV :: #type (device: VkDevice, pInfo: *VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *VkMemoryRequirements2KHR) -> void #c_call;
PFN_vkBindAccelerationStructureMemoryNV :: #type (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindAccelerationStructureMemoryInfoNV) -> VkResult #c_call;
PFN_vkCmdCopyAccelerationStructureNV :: #type (commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeKHR) -> void #c_call;
PFN_vkCmdCopyAccelerationStructureKHR :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyAccelerationStructureInfoKHR) -> void #c_call;
PFN_vkCopyAccelerationStructureKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyAccelerationStructureInfoKHR) -> VkResult #c_call;
PFN_vkCmdCopyAccelerationStructureToMemoryKHR :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyAccelerationStructureToMemoryInfoKHR) -> void #c_call;
PFN_vkCopyAccelerationStructureToMemoryKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyAccelerationStructureToMemoryInfoKHR) -> VkResult #c_call;
PFN_vkCmdCopyMemoryToAccelerationStructureKHR :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMemoryToAccelerationStructureInfoKHR) -> void #c_call;
PFN_vkCopyMemoryToAccelerationStructureKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMemoryToAccelerationStructureInfoKHR) -> VkResult #c_call;
PFN_vkCmdWriteAccelerationStructuresPropertiesKHR :: #type (commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureKHR, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) -> void #c_call;
PFN_vkCmdWriteAccelerationStructuresPropertiesNV :: #type (commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) -> void #c_call;
PFN_vkCmdBuildAccelerationStructureNV :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize) -> void #c_call;
PFN_vkWriteAccelerationStructuresPropertiesKHR :: #type (device: VkDevice, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureKHR, queryType: VkQueryType, dataSize: u64, pData: *void, stride: u64) -> VkResult #c_call;
PFN_vkCmdTraceRaysKHR :: #type (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) -> void #c_call;
PFN_vkCmdTraceRaysNV :: #type (commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: u32, height: u32, depth: u32) -> void #c_call;
PFN_vkGetRayTracingShaderGroupHandlesKHR :: #type (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: u64, pData: *void) -> VkResult #c_call;
PFN_vkGetRayTracingShaderGroupHandlesNV :: PFN_vkGetRayTracingShaderGroupHandlesKHR;
PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR :: #type (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: u64, pData: *void) -> VkResult #c_call;
PFN_vkGetAccelerationStructureHandleNV :: #type (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: u64, pData: *void) -> VkResult #c_call;
PFN_vkCreateRayTracingPipelinesNV :: #type (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkRayTracingPipelineCreateInfoNV, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkCreateRayTracingPipelinesKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkRayTracingPipelineCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeMatrixPropertiesNV) -> VkResult #c_call;
PFN_vkCmdTraceRaysIndirectKHR :: #type (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *VkStridedDeviceAddressRegionKHR, indirectDeviceAddress: VkDeviceAddress) -> void #c_call;
PFN_vkCmdTraceRaysIndirect2KHR :: #type (commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) -> void #c_call;
PFN_vkGetClusterAccelerationStructureBuildSizesNV :: #type (device: VkDevice, pInfo: *VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR) -> void #c_call;
PFN_vkCmdBuildClusterAccelerationStructureIndirectNV :: #type (commandBuffer: VkCommandBuffer, pCommandInfos: *VkClusterAccelerationStructureCommandsInfoNV) -> void #c_call;
PFN_vkGetDeviceAccelerationStructureCompatibilityKHR :: #type (device: VkDevice, pVersionInfo: *VkAccelerationStructureVersionInfoKHR, pCompatibility: *VkAccelerationStructureCompatibilityKHR) -> void #c_call;
PFN_vkGetRayTracingShaderGroupStackSizeKHR :: #type (device: VkDevice, pipeline: VkPipeline, group: u32, groupShader: VkShaderGroupShaderKHR) -> VkDeviceSize #c_call;
PFN_vkCmdSetRayTracingPipelineStackSizeKHR :: #type (commandBuffer: VkCommandBuffer, pipelineStackSize: u32) -> void #c_call;
PFN_vkGetImageViewHandleNVX :: #type (device: VkDevice, pInfo: *VkImageViewHandleInfoNVX) -> u32 #c_call;
PFN_vkGetImageViewHandle64NVX :: #type (device: VkDevice, pInfo: *VkImageViewHandleInfoNVX) -> u64 #c_call;
PFN_vkGetImageViewAddressNVX :: #type (device: VkDevice, imageView: VkImageView, pProperties: *VkImageViewAddressPropertiesNVX) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT :: #type (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pPresentModeCount: *u32, pPresentModes: *VkPresentModeKHR) -> VkResult #c_call;
PFN_vkGetDeviceGroupSurfacePresentModes2EXT :: #type (device: VkDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pModes: *VkDeviceGroupPresentModeFlagsKHR) -> VkResult #c_call;
PFN_vkAcquireFullScreenExclusiveModeEXT :: #type (device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult #c_call;
PFN_vkReleaseFullScreenExclusiveModeEXT :: #type (device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult #c_call;
PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: #type (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *u32, pCounters: *VkPerformanceCounterKHR, pCounterDescriptions: *VkPerformanceCounterDescriptionKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: #type (physicalDevice: VkPhysicalDevice, pPerformanceQueryCreateInfo: *VkQueryPoolPerformanceCreateInfoKHR, pNumPasses: *u32) -> void #c_call;
PFN_vkAcquireProfilingLockKHR :: #type (device: VkDevice, pInfo: *VkAcquireProfilingLockInfoKHR) -> VkResult #c_call;
PFN_vkReleaseProfilingLockKHR :: #type (device: VkDevice) -> void #c_call;
PFN_vkGetImageDrmFormatModifierPropertiesEXT :: #type (device: VkDevice, image: VkImage, pProperties: *VkImageDrmFormatModifierPropertiesEXT) -> VkResult #c_call;
PFN_vkGetBufferOpaqueCaptureAddress :: #type (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) -> u64 #c_call;
PFN_vkGetBufferOpaqueCaptureAddressKHR :: PFN_vkGetBufferOpaqueCaptureAddress;
PFN_vkGetBufferDeviceAddress :: #type (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) -> VkDeviceAddress #c_call;
PFN_vkGetBufferDeviceAddressKHR :: PFN_vkGetBufferDeviceAddress;
PFN_vkGetBufferDeviceAddressEXT :: PFN_vkGetBufferDeviceAddress;
PFN_vkCreateHeadlessSurfaceEXT :: #type (instance: VkInstance, pCreateInfo: *VkHeadlessSurfaceCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: #type (physicalDevice: VkPhysicalDevice, pCombinationCount: *u32, pCombinations: *VkFramebufferMixedSamplesCombinationNV) -> VkResult #c_call;
PFN_vkInitializePerformanceApiINTEL :: #type (device: VkDevice, pInitializeInfo: *VkInitializePerformanceApiInfoINTEL) -> VkResult #c_call;
PFN_vkUninitializePerformanceApiINTEL :: #type (device: VkDevice) -> void #c_call;
PFN_vkCmdSetPerformanceMarkerINTEL :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceMarkerInfoINTEL) -> VkResult #c_call;
PFN_vkCmdSetPerformanceStreamMarkerINTEL :: #type (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceStreamMarkerInfoINTEL) -> VkResult #c_call;
PFN_vkCmdSetPerformanceOverrideINTEL :: #type (commandBuffer: VkCommandBuffer, pOverrideInfo: *VkPerformanceOverrideInfoINTEL) -> VkResult #c_call;
PFN_vkAcquirePerformanceConfigurationINTEL :: #type (device: VkDevice, pAcquireInfo: *VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: *VkPerformanceConfigurationINTEL) -> VkResult #c_call;
PFN_vkReleasePerformanceConfigurationINTEL :: #type (device: VkDevice, configuration: VkPerformanceConfigurationINTEL) -> VkResult #c_call;
PFN_vkQueueSetPerformanceConfigurationINTEL :: #type (queue: VkQueue, configuration: VkPerformanceConfigurationINTEL) -> VkResult #c_call;
PFN_vkGetPerformanceParameterINTEL :: #type (device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: *VkPerformanceValueINTEL) -> VkResult #c_call;
PFN_vkGetDeviceMemoryOpaqueCaptureAddress :: #type (device: VkDevice, pInfo: *VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64 #c_call;
PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR :: PFN_vkGetDeviceMemoryOpaqueCaptureAddress;
PFN_vkGetPipelineExecutablePropertiesKHR :: #type (device: VkDevice, pPipelineInfo: *VkPipelineInfoKHR, pExecutableCount: *u32, pProperties: *VkPipelineExecutablePropertiesKHR) -> VkResult #c_call;
PFN_vkGetPipelineExecutableStatisticsKHR :: #type (device: VkDevice, pExecutableInfo: *VkPipelineExecutableInfoKHR, pStatisticCount: *u32, pStatistics: *VkPipelineExecutableStatisticKHR) -> VkResult #c_call;
PFN_vkGetPipelineExecutableInternalRepresentationsKHR :: #type (device: VkDevice, pExecutableInfo: *VkPipelineExecutableInfoKHR, pInternalRepresentationCount: *u32, pInternalRepresentations: *VkPipelineExecutableInternalRepresentationKHR) -> VkResult #c_call;
PFN_vkCmdSetLineStipple :: #type (commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> void #c_call;
PFN_vkCmdSetLineStippleKHR :: PFN_vkCmdSetLineStipple;
PFN_vkCmdSetLineStippleEXT :: PFN_vkCmdSetLineStipple;
PFN_vkGetFaultData :: #type (device: VkDevice, faultQueryBehavior: VkFaultQueryBehavior, pUnrecordedFaults: *VkBool32, pFaultCount: *u32, pFaults: *VkFaultData) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceToolProperties :: #type (physicalDevice: VkPhysicalDevice, pToolCount: *u32, pToolProperties: *VkPhysicalDeviceToolProperties) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceToolPropertiesEXT :: PFN_vkGetPhysicalDeviceToolProperties;
PFN_vkCreateAccelerationStructureKHR :: #type (device: VkDevice, pCreateInfo: *VkAccelerationStructureCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pAccelerationStructure: *VkAccelerationStructureKHR) -> VkResult #c_call;
PFN_vkCmdBuildAccelerationStructuresKHR :: #type (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: *VkAccelerationStructureBuildRangeInfoKHR) -> void #c_call;
PFN_vkCmdBuildAccelerationStructuresIndirectKHR :: #type (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, pIndirectDeviceAddresses: *VkDeviceAddress, pIndirectStrides: *u32, ppMaxPrimitiveCounts: *u32) -> void #c_call;
PFN_vkBuildAccelerationStructuresKHR :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: *VkAccelerationStructureBuildRangeInfoKHR) -> VkResult #c_call;
PFN_vkGetAccelerationStructureDeviceAddressKHR :: #type (device: VkDevice, pInfo: *VkAccelerationStructureDeviceAddressInfoKHR) -> VkDeviceAddress #c_call;
PFN_vkCreateDeferredOperationKHR :: #type (device: VkDevice, pAllocator: *VkAllocationCallbacks, pDeferredOperation: *VkDeferredOperationKHR) -> VkResult #c_call;
PFN_vkDestroyDeferredOperationKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetDeferredOperationMaxConcurrencyKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR) -> u32 #c_call;
PFN_vkGetDeferredOperationResultKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult #c_call;
PFN_vkDeferredOperationJoinKHR :: #type (device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult #c_call;
PFN_vkGetPipelineIndirectMemoryRequirementsNV :: #type (device: VkDevice, pCreateInfo: *VkComputePipelineCreateInfo, pMemoryRequirements: *VkMemoryRequirements2) -> void #c_call;
PFN_vkGetPipelineIndirectDeviceAddressNV :: #type (device: VkDevice, pInfo: *VkPipelineIndirectDeviceAddressInfoNV) -> VkDeviceAddress #c_call;
PFN_vkAntiLagUpdateAMD :: #type (device: VkDevice, pData: *VkAntiLagDataAMD) -> void #c_call;
PFN_vkCmdSetCullMode :: #type (commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> void #c_call;
PFN_vkCmdSetCullModeEXT :: PFN_vkCmdSetCullMode;
PFN_vkCmdSetFrontFace :: #type (commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) -> void #c_call;
PFN_vkCmdSetFrontFaceEXT :: PFN_vkCmdSetFrontFace;
PFN_vkCmdSetPrimitiveTopology :: #type (commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) -> void #c_call;
PFN_vkCmdSetPrimitiveTopologyEXT :: PFN_vkCmdSetPrimitiveTopology;
PFN_vkCmdSetViewportWithCount :: #type (commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *VkViewport) -> void #c_call;
PFN_vkCmdSetViewportWithCountEXT :: PFN_vkCmdSetViewportWithCount;
PFN_vkCmdSetScissorWithCount :: #type (commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *VkRect2D) -> void #c_call;
PFN_vkCmdSetScissorWithCountEXT :: PFN_vkCmdSetScissorWithCount;
PFN_vkCmdBindIndexBuffer2 :: #type (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> void #c_call;
PFN_vkCmdBindIndexBuffer2KHR :: PFN_vkCmdBindIndexBuffer2;
PFN_vkCmdBindVertexBuffers2 :: #type (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize, pStrides: *VkDeviceSize) -> void #c_call;
PFN_vkCmdBindVertexBuffers2EXT :: PFN_vkCmdBindVertexBuffers2;
PFN_vkCmdSetDepthTestEnable :: #type (commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthTestEnableEXT :: PFN_vkCmdSetDepthTestEnable;
PFN_vkCmdSetDepthWriteEnable :: #type (commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthWriteEnableEXT :: PFN_vkCmdSetDepthWriteEnable;
PFN_vkCmdSetDepthCompareOp :: #type (commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) -> void #c_call;
PFN_vkCmdSetDepthCompareOpEXT :: PFN_vkCmdSetDepthCompareOp;
PFN_vkCmdSetDepthBoundsTestEnable :: #type (commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthBoundsTestEnableEXT :: PFN_vkCmdSetDepthBoundsTestEnable;
PFN_vkCmdSetStencilTestEnable :: #type (commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetStencilTestEnableEXT :: PFN_vkCmdSetStencilTestEnable;
PFN_vkCmdSetStencilOp :: #type (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) -> void #c_call;
PFN_vkCmdSetStencilOpEXT :: PFN_vkCmdSetStencilOp;
PFN_vkCmdSetPatchControlPointsEXT :: #type (commandBuffer: VkCommandBuffer, patchControlPoints: u32) -> void #c_call;
PFN_vkCmdSetRasterizerDiscardEnable :: #type (commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetRasterizerDiscardEnableEXT :: PFN_vkCmdSetRasterizerDiscardEnable;
PFN_vkCmdSetDepthBiasEnable :: #type (commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthBiasEnableEXT :: PFN_vkCmdSetDepthBiasEnable;
PFN_vkCmdSetLogicOpEXT :: #type (commandBuffer: VkCommandBuffer, logicOp: VkLogicOp) -> void #c_call;
PFN_vkCmdSetPrimitiveRestartEnable :: #type (commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetPrimitiveRestartEnableEXT :: PFN_vkCmdSetPrimitiveRestartEnable;
PFN_vkCmdSetTessellationDomainOriginEXT :: #type (commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin) -> void #c_call;
PFN_vkCmdSetDepthClampEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetPolygonModeEXT :: #type (commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode) -> void #c_call;
PFN_vkCmdSetRasterizationSamplesEXT :: #type (commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits) -> void #c_call;
PFN_vkCmdSetSampleMaskEXT :: #type (commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: *VkSampleMask) -> void #c_call;
PFN_vkCmdSetAlphaToCoverageEnableEXT :: #type (commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetAlphaToOneEnableEXT :: #type (commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetLogicOpEnableEXT :: #type (commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetColorBlendEnableEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEnables: *VkBool32) -> void #c_call;
PFN_vkCmdSetColorBlendEquationEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEquations: *VkColorBlendEquationEXT) -> void #c_call;
PFN_vkCmdSetColorWriteMaskEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorWriteMasks: *VkColorComponentFlags) -> void #c_call;
PFN_vkCmdSetRasterizationStreamEXT :: #type (commandBuffer: VkCommandBuffer, rasterizationStream: u32) -> void #c_call;
PFN_vkCmdSetConservativeRasterizationModeEXT :: #type (commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT) -> void #c_call;
PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT :: #type (commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: float) -> void #c_call;
PFN_vkCmdSetDepthClipEnableEXT :: #type (commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetSampleLocationsEnableEXT :: #type (commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetColorBlendAdvancedEXT :: #type (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendAdvanced: *VkColorBlendAdvancedEXT) -> void #c_call;
PFN_vkCmdSetProvokingVertexModeEXT :: #type (commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT) -> void #c_call;
PFN_vkCmdSetLineRasterizationModeEXT :: #type (commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT) -> void #c_call;
PFN_vkCmdSetLineStippleEnableEXT :: #type (commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetDepthClipNegativeOneToOneEXT :: #type (commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32) -> void #c_call;
PFN_vkCmdSetViewportWScalingEnableNV :: #type (commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetViewportSwizzleNV :: #type (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportSwizzles: *VkViewportSwizzleNV) -> void #c_call;
PFN_vkCmdSetCoverageToColorEnableNV :: #type (commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetCoverageToColorLocationNV :: #type (commandBuffer: VkCommandBuffer, coverageToColorLocation: u32) -> void #c_call;
PFN_vkCmdSetCoverageModulationModeNV :: #type (commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV) -> void #c_call;
PFN_vkCmdSetCoverageModulationTableEnableNV :: #type (commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetCoverageModulationTableNV :: #type (commandBuffer: VkCommandBuffer, coverageModulationTableCount: u32, pCoverageModulationTable: *float) -> void #c_call;
PFN_vkCmdSetShadingRateImageEnableNV :: #type (commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32) -> void #c_call;
PFN_vkCmdSetCoverageReductionModeNV :: #type (commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV) -> void #c_call;
PFN_vkCmdSetRepresentativeFragmentTestEnableNV :: #type (commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32) -> void #c_call;
PFN_vkCreatePrivateDataSlot :: #type (device: VkDevice, pCreateInfo: *VkPrivateDataSlotCreateInfo, pAllocator: *VkAllocationCallbacks, pPrivateDataSlot: *VkPrivateDataSlot) -> VkResult #c_call;
PFN_vkCreatePrivateDataSlotEXT :: PFN_vkCreatePrivateDataSlot;
PFN_vkDestroyPrivateDataSlot :: #type (device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDestroyPrivateDataSlotEXT :: PFN_vkDestroyPrivateDataSlot;
PFN_vkSetPrivateData :: #type (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult #c_call;
PFN_vkSetPrivateDataEXT :: PFN_vkSetPrivateData;
PFN_vkGetPrivateData :: #type (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *u64) -> void #c_call;
PFN_vkGetPrivateDataEXT :: PFN_vkGetPrivateData;
PFN_vkCmdCopyBuffer2 :: #type (commandBuffer: VkCommandBuffer, pCopyBufferInfo: *VkCopyBufferInfo2) -> void #c_call;
PFN_vkCmdCopyBuffer2KHR :: PFN_vkCmdCopyBuffer2;
PFN_vkCmdCopyImage2 :: #type (commandBuffer: VkCommandBuffer, pCopyImageInfo: *VkCopyImageInfo2) -> void #c_call;
PFN_vkCmdCopyImage2KHR :: PFN_vkCmdCopyImage2;
PFN_vkCmdBlitImage2 :: #type (commandBuffer: VkCommandBuffer, pBlitImageInfo: *VkBlitImageInfo2) -> void #c_call;
PFN_vkCmdBlitImage2KHR :: PFN_vkCmdBlitImage2;
PFN_vkCmdCopyBufferToImage2 :: #type (commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *VkCopyBufferToImageInfo2) -> void #c_call;
PFN_vkCmdCopyBufferToImage2KHR :: PFN_vkCmdCopyBufferToImage2;
PFN_vkCmdCopyImageToBuffer2 :: #type (commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *VkCopyImageToBufferInfo2) -> void #c_call;
PFN_vkCmdCopyImageToBuffer2KHR :: PFN_vkCmdCopyImageToBuffer2;
PFN_vkCmdResolveImage2 :: #type (commandBuffer: VkCommandBuffer, pResolveImageInfo: *VkResolveImageInfo2) -> void #c_call;
PFN_vkCmdResolveImage2KHR :: PFN_vkCmdResolveImage2;
PFN_vkCmdRefreshObjectsKHR :: #type (commandBuffer: VkCommandBuffer, pRefreshObjects: *VkRefreshObjectListKHR) -> void #c_call;
PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR :: #type (physicalDevice: VkPhysicalDevice, pRefreshableObjectTypeCount: *u32, pRefreshableObjectTypes: *VkObjectType) -> VkResult #c_call;
PFN_vkCmdSetFragmentShadingRateKHR :: #type (commandBuffer: VkCommandBuffer, pFragmentSize: *VkExtent2D, combinerOps: /* [2] */*VkFragmentShadingRateCombinerOpKHR) -> void #c_call;
PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR :: #type (physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *u32, pFragmentShadingRates: *VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult #c_call;
PFN_vkCmdSetFragmentShadingRateEnumNV :: #type (commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: /* [2] */*VkFragmentShadingRateCombinerOpKHR) -> void #c_call;
PFN_vkGetAccelerationStructureBuildSizesKHR :: #type (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *VkAccelerationStructureBuildGeometryInfoKHR, pMaxPrimitiveCounts: *u32, pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR) -> void #c_call;
PFN_vkCmdSetVertexInputEXT :: #type (commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *VkVertexInputAttributeDescription2EXT) -> void #c_call;
PFN_vkCmdSetColorWriteEnableEXT :: #type (commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *VkBool32) -> void #c_call;
PFN_vkCmdSetEvent2 :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdSetEvent2KHR :: PFN_vkCmdSetEvent2;
PFN_vkCmdResetEvent2 :: #type (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) -> void #c_call;
PFN_vkCmdResetEvent2KHR :: PFN_vkCmdResetEvent2;
PFN_vkCmdWaitEvents2 :: #type (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, pDependencyInfos: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdWaitEvents2KHR :: PFN_vkCmdWaitEvents2;
PFN_vkCmdPipelineBarrier2 :: #type (commandBuffer: VkCommandBuffer, pDependencyInfo: *VkDependencyInfo) -> void #c_call;
PFN_vkCmdPipelineBarrier2KHR :: PFN_vkCmdPipelineBarrier2;
PFN_vkQueueSubmit2 :: #type (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo2, fence: VkFence) -> VkResult #c_call;
PFN_vkQueueSubmit2KHR :: PFN_vkQueueSubmit2;
PFN_vkCmdWriteTimestamp2 :: #type (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) -> void #c_call;
PFN_vkCmdWriteTimestamp2KHR :: PFN_vkCmdWriteTimestamp2;
PFN_vkCmdWriteBufferMarker2AMD :: #type (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) -> void #c_call;
PFN_vkGetQueueCheckpointData2NV :: #type (queue: VkQueue, pCheckpointDataCount: *u32, pCheckpointData: *VkCheckpointData2NV) -> void #c_call;
PFN_vkCopyMemoryToImage :: #type (device: VkDevice, pCopyMemoryToImageInfo: *VkCopyMemoryToImageInfo) -> VkResult #c_call;
PFN_vkCopyMemoryToImageEXT :: PFN_vkCopyMemoryToImage;
PFN_vkCopyImageToMemory :: #type (device: VkDevice, pCopyImageToMemoryInfo: *VkCopyImageToMemoryInfo) -> VkResult #c_call;
PFN_vkCopyImageToMemoryEXT :: PFN_vkCopyImageToMemory;
PFN_vkCopyImageToImage :: #type (device: VkDevice, pCopyImageToImageInfo: *VkCopyImageToImageInfo) -> VkResult #c_call;
PFN_vkCopyImageToImageEXT :: PFN_vkCopyImageToImage;
PFN_vkTransitionImageLayout :: #type (device: VkDevice, transitionCount: u32, pTransitions: *VkHostImageLayoutTransitionInfo) -> VkResult #c_call;
PFN_vkTransitionImageLayoutEXT :: PFN_vkTransitionImageLayout;
PFN_vkGetCommandPoolMemoryConsumption :: #type (device: VkDevice, commandPool: VkCommandPool, commandBuffer: VkCommandBuffer, pConsumption: *VkCommandPoolMemoryConsumption) -> void #c_call;
PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR :: #type (physicalDevice: VkPhysicalDevice, pVideoProfile: *VkVideoProfileInfoKHR, pCapabilities: *VkVideoCapabilitiesKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pVideoFormatInfo: *VkPhysicalDeviceVideoFormatInfoKHR, pVideoFormatPropertyCount: *u32, pVideoFormatProperties: *VkVideoFormatPropertiesKHR) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult #c_call;
PFN_vkCreateVideoSessionKHR :: #type (device: VkDevice, pCreateInfo: *VkVideoSessionCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pVideoSession: *VkVideoSessionKHR) -> VkResult #c_call;
PFN_vkDestroyVideoSessionKHR :: #type (device: VkDevice, videoSession: VkVideoSessionKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCreateVideoSessionParametersKHR :: #type (device: VkDevice, pCreateInfo: *VkVideoSessionParametersCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pVideoSessionParameters: *VkVideoSessionParametersKHR) -> VkResult #c_call;
PFN_vkUpdateVideoSessionParametersKHR :: #type (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pUpdateInfo: *VkVideoSessionParametersUpdateInfoKHR) -> VkResult #c_call;
PFN_vkGetEncodedVideoSessionParametersKHR :: #type (device: VkDevice, pVideoSessionParametersInfo: *VkVideoEncodeSessionParametersGetInfoKHR, pFeedbackInfo: *VkVideoEncodeSessionParametersFeedbackInfoKHR, pDataSize: *u64, pData: *void) -> VkResult #c_call;
PFN_vkDestroyVideoSessionParametersKHR :: #type (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetVideoSessionMemoryRequirementsKHR :: #type (device: VkDevice, videoSession: VkVideoSessionKHR, pMemoryRequirementsCount: *u32, pMemoryRequirements: *VkVideoSessionMemoryRequirementsKHR) -> VkResult #c_call;
PFN_vkBindVideoSessionMemoryKHR :: #type (device: VkDevice, videoSession: VkVideoSessionKHR, bindSessionMemoryInfoCount: u32, pBindSessionMemoryInfos: *VkBindVideoSessionMemoryInfoKHR) -> VkResult #c_call;
PFN_vkCmdDecodeVideoKHR :: #type (commandBuffer: VkCommandBuffer, pDecodeInfo: *VkVideoDecodeInfoKHR) -> void #c_call;
PFN_vkCmdBeginVideoCodingKHR :: #type (commandBuffer: VkCommandBuffer, pBeginInfo: *VkVideoBeginCodingInfoKHR) -> void #c_call;
PFN_vkCmdControlVideoCodingKHR :: #type (commandBuffer: VkCommandBuffer, pCodingControlInfo: *VkVideoCodingControlInfoKHR) -> void #c_call;
PFN_vkCmdEndVideoCodingKHR :: #type (commandBuffer: VkCommandBuffer, pEndCodingInfo: *VkVideoEndCodingInfoKHR) -> void #c_call;
PFN_vkCmdEncodeVideoKHR :: #type (commandBuffer: VkCommandBuffer, pEncodeInfo: *VkVideoEncodeInfoKHR) -> void #c_call;
PFN_vkCmdDecompressMemoryNV :: #type (commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *VkDecompressMemoryRegionNV) -> void #c_call;
PFN_vkCmdDecompressMemoryIndirectCountNV :: #type (commandBuffer: VkCommandBuffer, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, stride: u32) -> void #c_call;
PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV :: #type (device: VkDevice, pInfo: *VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR) -> void #c_call;
PFN_vkCmdBuildPartitionedAccelerationStructuresNV :: #type (commandBuffer: VkCommandBuffer, pBuildInfo: *VkBuildPartitionedAccelerationStructureInfoNV) -> void #c_call;
PFN_vkCreateCuModuleNVX :: #type (device: VkDevice, pCreateInfo: *VkCuModuleCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pModule: *VkCuModuleNVX) -> VkResult #c_call;
PFN_vkCreateCuFunctionNVX :: #type (device: VkDevice, pCreateInfo: *VkCuFunctionCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pFunction: *VkCuFunctionNVX) -> VkResult #c_call;
PFN_vkDestroyCuModuleNVX :: #type (device: VkDevice, module: VkCuModuleNVX, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDestroyCuFunctionNVX :: #type (device: VkDevice, function: VkCuFunctionNVX, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdCuLaunchKernelNVX :: #type (commandBuffer: VkCommandBuffer, pLaunchInfo: *VkCuLaunchInfoNVX) -> void #c_call;
PFN_vkGetDescriptorSetLayoutSizeEXT :: #type (device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *VkDeviceSize) -> void #c_call;
PFN_vkGetDescriptorSetLayoutBindingOffsetEXT :: #type (device: VkDevice, layout: VkDescriptorSetLayout, binding: u32, pOffset: *VkDeviceSize) -> void #c_call;
PFN_vkGetDescriptorEXT :: #type (device: VkDevice, pDescriptorInfo: *VkDescriptorGetInfoEXT, dataSize: u64, pDescriptor: *void) -> void #c_call;
PFN_vkCmdBindDescriptorBuffersEXT :: #type (commandBuffer: VkCommandBuffer, bufferCount: u32, pBindingInfos: *VkDescriptorBufferBindingInfoEXT) -> void #c_call;
PFN_vkCmdSetDescriptorBufferOffsetsEXT :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, setCount: u32, pBufferIndices: *u32, pOffsets: *VkDeviceSize) -> void #c_call;
PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT :: #type (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32) -> void #c_call;
PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkBufferCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetImageOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkImageCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkImageViewCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkSamplerCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT :: #type (device: VkDevice, pInfo: *VkAccelerationStructureCaptureDescriptorDataInfoEXT, pData: *void) -> VkResult #c_call;
PFN_vkSetDeviceMemoryPriorityEXT :: #type (device: VkDevice, memory: VkDeviceMemory, priority: float) -> void #c_call;
PFN_vkAcquireDrmDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, drmFd: s32, display: VkDisplayKHR) -> VkResult #c_call;
PFN_vkGetDrmDisplayEXT :: #type (physicalDevice: VkPhysicalDevice, drmFd: s32, connectorId: u32, display: *VkDisplayKHR) -> VkResult #c_call;
PFN_vkWaitForPresentKHR :: #type (device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> VkResult #c_call;
PFN_vkCreateBufferCollectionFUCHSIA :: #type (device: VkDevice, pCreateInfo: *VkBufferCollectionCreateInfoFUCHSIA, pAllocator: *VkAllocationCallbacks, pCollection: *VkBufferCollectionFUCHSIA) -> VkResult #c_call;
PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA :: #type (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pBufferConstraintsInfo: *VkBufferConstraintsInfoFUCHSIA) -> VkResult #c_call;
PFN_vkSetBufferCollectionImageConstraintsFUCHSIA :: #type (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pImageConstraintsInfo: *VkImageConstraintsInfoFUCHSIA) -> VkResult #c_call;
PFN_vkDestroyBufferCollectionFUCHSIA :: #type (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetBufferCollectionPropertiesFUCHSIA :: #type (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pProperties: *VkBufferCollectionPropertiesFUCHSIA) -> VkResult #c_call;
PFN_vkCreateCudaModuleNV :: #type (device: VkDevice, pCreateInfo: *VkCudaModuleCreateInfoNV, pAllocator: *VkAllocationCallbacks, pModule: *VkCudaModuleNV) -> VkResult #c_call;
PFN_vkGetCudaModuleCacheNV :: #type (device: VkDevice, module: VkCudaModuleNV, pCacheSize: *u64, pCacheData: *void) -> VkResult #c_call;
PFN_vkCreateCudaFunctionNV :: #type (device: VkDevice, pCreateInfo: *VkCudaFunctionCreateInfoNV, pAllocator: *VkAllocationCallbacks, pFunction: *VkCudaFunctionNV) -> VkResult #c_call;
PFN_vkDestroyCudaModuleNV :: #type (device: VkDevice, module: VkCudaModuleNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkDestroyCudaFunctionNV :: #type (device: VkDevice, function: VkCudaFunctionNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdCudaLaunchKernelNV :: #type (commandBuffer: VkCommandBuffer, pLaunchInfo: *VkCudaLaunchInfoNV) -> void #c_call;
PFN_vkCmdBeginRendering :: #type (commandBuffer: VkCommandBuffer, pRenderingInfo: *VkRenderingInfo) -> void #c_call;
PFN_vkCmdBeginRenderingKHR :: PFN_vkCmdBeginRendering;
PFN_vkCmdEndRendering :: #type (commandBuffer: VkCommandBuffer) -> void #c_call;
PFN_vkCmdEndRenderingKHR :: PFN_vkCmdEndRendering;
PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE :: #type (device: VkDevice, pBindingReference: *VkDescriptorSetBindingReferenceVALVE, pHostMapping: *VkDescriptorSetLayoutHostMappingInfoVALVE) -> void #c_call;
PFN_vkGetDescriptorSetHostMappingVALVE :: #type (device: VkDevice, descriptorSet: VkDescriptorSet, ppData: **void) -> void #c_call;
PFN_vkCreateMicromapEXT :: #type (device: VkDevice, pCreateInfo: *VkMicromapCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pMicromap: *VkMicromapEXT) -> VkResult #c_call;
PFN_vkCmdBuildMicromapsEXT :: #type (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkMicromapBuildInfoEXT) -> void #c_call;
PFN_vkBuildMicromapsEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *VkMicromapBuildInfoEXT) -> VkResult #c_call;
PFN_vkDestroyMicromapEXT :: #type (device: VkDevice, micromap: VkMicromapEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkCmdCopyMicromapEXT :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMicromapInfoEXT) -> void #c_call;
PFN_vkCopyMicromapEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMicromapInfoEXT) -> VkResult #c_call;
PFN_vkCmdCopyMicromapToMemoryEXT :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMicromapToMemoryInfoEXT) -> void #c_call;
PFN_vkCopyMicromapToMemoryEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMicromapToMemoryInfoEXT) -> VkResult #c_call;
PFN_vkCmdCopyMemoryToMicromapEXT :: #type (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMemoryToMicromapInfoEXT) -> void #c_call;
PFN_vkCopyMemoryToMicromapEXT :: #type (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMemoryToMicromapInfoEXT) -> VkResult #c_call;
PFN_vkCmdWriteMicromapsPropertiesEXT :: #type (commandBuffer: VkCommandBuffer, micromapCount: u32, pMicromaps: *VkMicromapEXT, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) -> void #c_call;
PFN_vkWriteMicromapsPropertiesEXT :: #type (device: VkDevice, micromapCount: u32, pMicromaps: *VkMicromapEXT, queryType: VkQueryType, dataSize: u64, pData: *void, stride: u64) -> VkResult #c_call;
PFN_vkGetDeviceMicromapCompatibilityEXT :: #type (device: VkDevice, pVersionInfo: *VkMicromapVersionInfoEXT, pCompatibility: *VkAccelerationStructureCompatibilityKHR) -> void #c_call;
PFN_vkGetMicromapBuildSizesEXT :: #type (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *VkMicromapBuildInfoEXT, pSizeInfo: *VkMicromapBuildSizesInfoEXT) -> void #c_call;
PFN_vkGetShaderModuleIdentifierEXT :: #type (device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *VkShaderModuleIdentifierEXT) -> void #c_call;
PFN_vkGetShaderModuleCreateInfoIdentifierEXT :: #type (device: VkDevice, pCreateInfo: *VkShaderModuleCreateInfo, pIdentifier: *VkShaderModuleIdentifierEXT) -> void #c_call;
PFN_vkGetImageSubresourceLayout2 :: #type (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource2, pLayout: *VkSubresourceLayout2) -> void #c_call;
PFN_vkGetImageSubresourceLayout2KHR :: PFN_vkGetImageSubresourceLayout2;
PFN_vkGetImageSubresourceLayout2EXT :: PFN_vkGetImageSubresourceLayout2;
PFN_vkGetPipelinePropertiesEXT :: #type (device: VkDevice, pPipelineInfo: *VkPipelineInfoEXT, pPipelineProperties: *VkBaseOutStructure) -> VkResult #c_call;
PFN_vkExportMetalObjectsEXT :: #type (device: VkDevice, pMetalObjectsInfo: *VkExportMetalObjectsInfoEXT) -> void #c_call;
PFN_vkGetFramebufferTilePropertiesQCOM :: #type (device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *u32, pProperties: *VkTilePropertiesQCOM) -> VkResult #c_call;
PFN_vkGetDynamicRenderingTilePropertiesQCOM :: #type (device: VkDevice, pRenderingInfo: *VkRenderingInfo, pProperties: *VkTilePropertiesQCOM) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV :: #type (physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *VkOpticalFlowImageFormatInfoNV, pFormatCount: *u32, pImageFormatProperties: *VkOpticalFlowImageFormatPropertiesNV) -> VkResult #c_call;
PFN_vkCreateOpticalFlowSessionNV :: #type (device: VkDevice, pCreateInfo: *VkOpticalFlowSessionCreateInfoNV, pAllocator: *VkAllocationCallbacks, pSession: *VkOpticalFlowSessionNV) -> VkResult #c_call;
PFN_vkDestroyOpticalFlowSessionNV :: #type (device: VkDevice, session: VkOpticalFlowSessionNV, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkBindOpticalFlowSessionImageNV :: #type (device: VkDevice, session: VkOpticalFlowSessionNV, bindingPoint: VkOpticalFlowSessionBindingPointNV, view: VkImageView, layout: VkImageLayout) -> VkResult #c_call;
PFN_vkCmdOpticalFlowExecuteNV :: #type (commandBuffer: VkCommandBuffer, session: VkOpticalFlowSessionNV, pExecuteInfo: *VkOpticalFlowExecuteInfoNV) -> void #c_call;
PFN_vkGetDeviceFaultInfoEXT :: #type (device: VkDevice, pFaultCounts: *VkDeviceFaultCountsEXT, pFaultInfo: *VkDeviceFaultInfoEXT) -> VkResult #c_call;
PFN_vkCmdSetDepthBias2EXT :: #type (commandBuffer: VkCommandBuffer, pDepthBiasInfo: *VkDepthBiasInfoEXT) -> void #c_call;
PFN_vkReleaseSwapchainImagesEXT :: #type (device: VkDevice, pReleaseInfo: *VkReleaseSwapchainImagesInfoEXT) -> VkResult #c_call;
PFN_vkGetDeviceImageSubresourceLayout :: #type (device: VkDevice, pInfo: *VkDeviceImageSubresourceInfo, pLayout: *VkSubresourceLayout2) -> void #c_call;
PFN_vkGetDeviceImageSubresourceLayoutKHR :: PFN_vkGetDeviceImageSubresourceLayout;
PFN_vkMapMemory2 :: #type (device: VkDevice, pMemoryMapInfo: *VkMemoryMapInfo, ppData: **void) -> VkResult #c_call;
PFN_vkMapMemory2KHR :: PFN_vkMapMemory2;
PFN_vkUnmapMemory2 :: #type (device: VkDevice, pMemoryUnmapInfo: *VkMemoryUnmapInfo) -> VkResult #c_call;
PFN_vkUnmapMemory2KHR :: PFN_vkUnmapMemory2;
PFN_vkCreateShadersEXT :: #type (device: VkDevice, createInfoCount: u32, pCreateInfos: *VkShaderCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pShaders: *VkShaderEXT) -> VkResult #c_call;
PFN_vkDestroyShaderEXT :: #type (device: VkDevice, shader: VkShaderEXT, pAllocator: *VkAllocationCallbacks) -> void #c_call;
PFN_vkGetShaderBinaryDataEXT :: #type (device: VkDevice, shader: VkShaderEXT, pDataSize: *u64, pData: *void) -> VkResult #c_call;
PFN_vkCmdBindShadersEXT :: #type (commandBuffer: VkCommandBuffer, stageCount: u32, pStages: *VkShaderStageFlagBits, pShaders: *VkShaderEXT) -> void #c_call;
PFN_vkGetScreenBufferPropertiesQNX :: #type (device: VkDevice, buffer: *_screen_buffer, pProperties: *VkScreenBufferPropertiesQNX) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeMatrixPropertiesKHR) -> VkResult #c_call;
PFN_vkGetExecutionGraphPipelineScratchSizeAMDX :: #type (device: VkDevice, executionGraph: VkPipeline, pSizeInfo: *VkExecutionGraphPipelineScratchSizeAMDX) -> VkResult #c_call;
PFN_vkGetExecutionGraphPipelineNodeIndexAMDX :: #type (device: VkDevice, executionGraph: VkPipeline, pNodeInfo: *VkPipelineShaderStageNodeCreateInfoAMDX, pNodeIndex: *u32) -> VkResult #c_call;
PFN_vkCreateExecutionGraphPipelinesAMDX :: #type (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkExecutionGraphPipelineCreateInfoAMDX, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) -> VkResult #c_call;
PFN_vkCmdInitializeGraphScratchMemoryAMDX :: #type (commandBuffer: VkCommandBuffer, executionGraph: VkPipeline, scratch: VkDeviceAddress, scratchSize: VkDeviceSize) -> void #c_call;
PFN_vkCmdDispatchGraphAMDX :: #type (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, pCountInfo: *VkDispatchGraphCountInfoAMDX) -> void #c_call;
PFN_vkCmdDispatchGraphIndirectAMDX :: #type (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, pCountInfo: *VkDispatchGraphCountInfoAMDX) -> void #c_call;
PFN_vkCmdDispatchGraphIndirectCountAMDX :: #type (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, countInfo: VkDeviceAddress) -> void #c_call;
PFN_vkCmdBindDescriptorSets2 :: #type (commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *VkBindDescriptorSetsInfo) -> void #c_call;
PFN_vkCmdBindDescriptorSets2KHR :: PFN_vkCmdBindDescriptorSets2;
PFN_vkCmdPushConstants2 :: #type (commandBuffer: VkCommandBuffer, pPushConstantsInfo: *VkPushConstantsInfo) -> void #c_call;
PFN_vkCmdPushConstants2KHR :: PFN_vkCmdPushConstants2;
PFN_vkCmdPushDescriptorSet2 :: #type (commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *VkPushDescriptorSetInfo) -> void #c_call;
PFN_vkCmdPushDescriptorSet2KHR :: PFN_vkCmdPushDescriptorSet2;
PFN_vkCmdPushDescriptorSetWithTemplate2 :: #type (commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *VkPushDescriptorSetWithTemplateInfo) -> void #c_call;
PFN_vkCmdPushDescriptorSetWithTemplate2KHR :: PFN_vkCmdPushDescriptorSetWithTemplate2;
PFN_vkCmdSetDescriptorBufferOffsets2EXT :: #type (commandBuffer: VkCommandBuffer, pSetDescriptorBufferOffsetsInfo: *VkSetDescriptorBufferOffsetsInfoEXT) -> void #c_call;
PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT :: #type (commandBuffer: VkCommandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo: *VkBindDescriptorBufferEmbeddedSamplersInfoEXT) -> void #c_call;
PFN_vkSetLatencySleepModeNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *VkLatencySleepModeInfoNV) -> VkResult #c_call;
PFN_vkLatencySleepNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pSleepInfo: *VkLatencySleepInfoNV) -> VkResult #c_call;
PFN_vkSetLatencyMarkerNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: *VkSetLatencyMarkerInfoNV) -> void #c_call;
PFN_vkGetLatencyTimingsNV :: #type (device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: *VkGetLatencyMarkerInfoNV) -> void #c_call;
PFN_vkQueueNotifyOutOfBandNV :: #type (queue: VkQueue, pQueueTypeInfo: *VkOutOfBandQueueTypeInfoNV) -> void #c_call;
PFN_vkCmdSetRenderingAttachmentLocations :: #type (commandBuffer: VkCommandBuffer, pLocationInfo: *VkRenderingAttachmentLocationInfo) -> void #c_call;
PFN_vkCmdSetRenderingAttachmentLocationsKHR :: PFN_vkCmdSetRenderingAttachmentLocations;
PFN_vkCmdSetRenderingInputAttachmentIndices :: #type (commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *VkRenderingInputAttachmentIndexInfo) -> void #c_call;
PFN_vkCmdSetRenderingInputAttachmentIndicesKHR :: PFN_vkCmdSetRenderingInputAttachmentIndices;
PFN_vkCmdSetDepthClampRangeEXT :: #type (commandBuffer: VkCommandBuffer, depthClampMode: VkDepthClampModeEXT, pDepthClampRange: *VkDepthClampRangeEXT) -> void #c_call;
PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult #c_call;
PFN_vkGetMemoryMetalHandleEXT :: #type (device: VkDevice, pGetMetalHandleInfo: *VkMemoryGetMetalHandleInfoEXT, pHandle: **void) -> VkResult #c_call;
PFN_vkGetMemoryMetalHandlePropertiesEXT :: #type (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHandle: *void, pMemoryMetalHandleProperties: *VkMemoryMetalHandlePropertiesEXT) -> VkResult #c_call;
PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV :: #type (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeVectorPropertiesNV) -> VkResult #c_call;
PFN_vkConvertCooperativeVectorMatrixNV :: #type (device: VkDevice, pInfo: *VkConvertCooperativeVectorMatrixInfoNV) -> VkResult #c_call;
PFN_vkCmdConvertCooperativeVectorMatrixNV :: #type (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkConvertCooperativeVectorMatrixInfoNV) -> void #c_call;
